//-----------------------------------------------------------------------------
// <auto-generated>
// This code was generated by GeneratedIdentifierSourceGenerator which
// can be found in the LightResults.Extensions.GeneratedIdentifier namespace.
//
// Changes to this file may cause incorrect behavior
// and will be lost if the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------------

#nullable enable

using System.ComponentModel;
using System.Globalization;
using System.Text.Json;
using System.Text.Json.Serialization;
using LightResults;
using LightResults.Extensions.ValueObjects;

namespace MyProject.Identifiers;

[TypeConverter(typeof(TestLongIdTypeConverter))]
[JsonConverter(typeof(TestLongIdJsonConverter))]
readonly partial struct TestLongId :
    ICreatableValueObject<long, TestLongId>,
    IParsableValueObject<TestLongId>,
    IValueObject<long, TestLongId>,
    IComparable<TestLongId>,
    IComparable
{
    /// <summary>Gets whether this identifier is the default value.</summary>
    public bool IsDefault => _value == default;

    long IValueObject<long, TestLongId>.Value => _value;

    private readonly long _value;

    private TestLongId(long value, bool skipValidation = false)
    {
        if (!skipValidation)
            ValueObjectException.ThrowIfFailed(Validate(value));

        _value = value;
    }

    /// <inheritdoc />
    public static TestLongId Create(long value)
    {
        var result = TryCreate(value);
        if (result.IsSuccess(out var identifier, out var error))
            return identifier;

        throw new ValueObjectException(error.Message);
    }

    /// <inheritdoc />
    public static Result<TestLongId> TryCreate(long value)
    {
        var validation = Validate(value);
        if (validation.IsFailed(out var error))
            return Result.Fail<TestLongId>(error);

        return Result.Ok<TestLongId>(new TestLongId(value, true));
    }

    /// <inheritdoc />
    public static TestLongId Parse(string s)
    {
        var result = TryParse(s);
        if (result.IsSuccess(out var identifier, out var error))
            return identifier;

        throw new ValueObjectException(error.Message);
    }

    /// <inheritdoc />
    public static Result<TestLongId> TryParse(string s)
    {
        if (long.TryParse(s, out var value))
            return TryCreate(value);

        return Result.Fail<TestLongId>("The string is not a valid identifier.");
    }

    /// <inheritdoc />
    public static bool TryParse(string s, out TestLongId identifier)
    {
        return TryParse(s).IsSuccess(out identifier);
    }

    /// <inheritdoc />
    public static bool TryParse(string s, IFormatProvider provider, out TestLongId identifier)
    {
        return TryParse(s).IsSuccess(out identifier);
    }

    /// <inheritdoc />
    public bool Equals(TestLongId other)
    {
        return _value == other._value;
    }

    /// <inheritdoc />
    public override bool Equals(object? obj)
    {
        return obj is TestLongId other && Equals(other);
    }

    /// <inheritdoc />
    public override int GetHashCode()
    {
        return _value.GetHashCode();
    }

    /// <summary>Determines whether two instances of <see cref="TestLongId" /> are equal.</summary>
    /// <param name="left">The first instance to compare.</param>
    /// <param name="right">The second instance to compare.</param>
    /// <returns><c>true</c> if the instances are equal; otherwise, <c>false</c>.</returns>
    public static bool operator ==(TestLongId left, TestLongId right)
    {
        return left.Equals(right);
    }

    /// <summary>Determines whether two instances of <see cref="TestLongId" /> are not equal.</summary>
    /// <param name="left">The first instance to compare.</param>
    /// <param name="right">The second instance to compare.</param>
    /// <returns><c>true</c> if the instances are not equal; otherwise, <c>false</c>.</returns>
    public static bool operator !=(TestLongId left, TestLongId right)
    {
        return !left.Equals(right);
    }

    /// <inheritdoc />
    public int CompareTo(TestLongId other)
    {
        return _value.CompareTo(other._value);
    }

    /// <inheritdoc />
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is TestLongId other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(TestLongId)}");
    }

    /// <summary>Determines whether the first instance of <see cref="TestLongId" /> is less than the second instance.</summary>
    /// <param name="left">The first instance to compare.</param>
    /// <param name="right">The second instance to compare.</param>
    /// <returns><c>true</c> if the first instance is less than the second instance; otherwise, <c>false</c>.</returns>
    public static bool operator <(TestLongId left, TestLongId right)
    {
        return left.CompareTo(right) < 0;
    }

    /// <summary>Determines whether the first instance of <see cref="TestLongId" /> is greater than the second instance.</summary>
    /// <param name="left">The first instance to compare.</param>
    /// <param name="right">The second instance to compare.</param>
    /// <returns><c>true</c> if the first instance is greater than the second instance; otherwise, <c>false</c>.</returns>
    public static bool operator >(TestLongId left, TestLongId right)
    {
        return left.CompareTo(right) > 0;
    }

    /// <summary>Determines whether the first instance of <see cref="TestLongId" /> is less than or equal to the second instance.</summary>
    /// <param name="left">The first instance to compare.</param>
    /// <param name="right">The second instance to compare.</param>
    /// <returns><c>true</c> if the first instance is less than or equal to the second instance; otherwise, <c>false</c>.</returns>
    public static bool operator <=(TestLongId left, TestLongId right)
    {
        return left.CompareTo(right) <= 0;
    }

    /// <summary>Determines whether the first instance of <see cref="TestLongId" /> is greater than or equal to the second instance.</summary>
    /// <param name="left">The first instance to compare.</param>
    /// <param name="right">The second instance to compare.</param>
    /// <returns><c>true</c> if the first instance is greater than or equal to the second instance; otherwise, <c>false</c>.</returns>
    public static bool operator >=(TestLongId left, TestLongId right)
    {
        return left.CompareTo(right) >= 0;
    }

    /// <summary>Gets the underlying value of the <see cref="TestLongId" />.</summary>
    /// <returns>The underlying value of the <see cref="TestLongId" />.</returns>
    public long ToInt64()
    {
        return _value;
    }

    /// <inheritdoc />
    public override string ToString()
    {
        return _value.ToString(CultureInfo.InvariantCulture);
    }

    private static Result Validate(long value)
    {
        if (value < 0)
            return Result.Fail("The value must be equal to or greater than zero.");

        return Result.Ok();
    }
}

public class TestLongIdTypeConverter : TypeConverter
{
    public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType)
    {
        return sourceType == typeof(long) || base.CanConvertFrom(context, sourceType);
    }

    public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value)
    {
        if (value is long identifierValue)
            return TestLongId.Create(identifierValue);

        return base.ConvertFrom(context, culture, value);
    }
}

public class TestLongIdJsonConverter : JsonConverter<TestLongId>
{
    public override void Write(Utf8JsonWriter writer, TestLongId identifier, JsonSerializerOptions options)
    {
        var value = ((IValueObject<long, TestLongId>)identifier).Value;
        writer.WriteNumberValue(value);
    }

    public override TestLongId Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var value = reader.GetInt64();
        return TestLongId.Create(value);
    }
}
