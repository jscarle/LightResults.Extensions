using System.Collections.Immutable;
using System.Text;
using LightResults.Extensions.GeneratedIdentifier.Common;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

namespace LightResults.Extensions.GeneratedIdentifier;

[Generator]
public sealed class GeneratedIdentifierSourceGenerator : IIncrementalGenerator
{
    private const string AttributesNamespace = "LightResults.Extensions.GeneratedIdentifier";
    private const string GeneratedIdentifierAttributeName = "GeneratedIdentifierAttribute";
    private const string GeneratedIdentifierAttributeFullyQualifiedName = $"{AttributesNamespace}.{GeneratedIdentifierAttributeName}`1";
    private const string GeneratedIdentifierAttributeHint = $"{GeneratedIdentifierAttributeFullyQualifiedName}.g.cs";

    private static readonly string FileHeader = $"""
                                                 //-----------------------------------------------------------------------------
                                                 // <auto-generated>
                                                 // This code was generated by {nameof(GeneratedIdentifierSourceGenerator)} which
                                                 // can be found in the {typeof(GeneratedIdentifierSourceGenerator).Namespace} namespace.
                                                 //
                                                 // Changes to this file may cause incorrect behavior
                                                 // and will be lost if the code is regenerated.
                                                 // </auto-generated>
                                                 //-----------------------------------------------------------------------------
                                                 #nullable enable
                                                 """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(RegisterAttributes);

        var generatedIdentifiers = context.SyntaxProvider
            .ForAttributeWithMetadataName(GeneratedIdentifierAttributeFullyQualifiedName, Filter, Transform)
            .WhereNotNull()
            .Collect();

        context.RegisterSourceOutput(generatedIdentifiers, GenerateIdentifier);
    }

    private static void RegisterAttributes(IncrementalGeneratorPostInitializationContext context)
    {
        var source = $"""
                      {FileHeader}

                      using System;

                      namespace {AttributesNamespace};

                      [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class)]
                      public sealed class {GeneratedIdentifierAttributeName}<TIdentifier> : Attribute;
                      """;
        context.AddSource(GeneratedIdentifierAttributeHint, SourceText.From(source, Encoding.UTF8));
    }

    private static bool Filter(SyntaxNode syntaxNode, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        return syntaxNode.IsKind(SyntaxKind.StructDeclaration) || syntaxNode.IsKind(SyntaxKind.ClassDeclaration);
    }

    private static Identifier? Transform(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (context.TargetSymbol is not INamedTypeSymbol namedTypeSymbol)
            return null;

        var containingDeclarations = namedTypeSymbol.GetContainingDeclarations(cancellationToken);
        var symbolName = namedTypeSymbol.Name;
        var isStruct = namedTypeSymbol.TypeKind == TypeKind.Struct;
        var isPublic = namedTypeSymbol.DeclaredAccessibility == Accessibility.Public;

        var attribute = context.Attributes[0].AttributeClass!;
        if (attribute.TypeArguments.Length != 1)
            return null;

        var typeArgument = attribute.TypeArguments[0];

        string? declaredValueType;
        string? fullValueType;
        switch (typeArgument.SpecialType)
        {
            case SpecialType.System_Int16:
                declaredValueType = "short";
                fullValueType = "Int16";
                break;
            case SpecialType.System_Int32:
                declaredValueType = "int";
                fullValueType = "Int32";
                break;
            case SpecialType.System_Int64:
                declaredValueType = "long";
                fullValueType = "Int64";
                break;
            case SpecialType.System_String:
                declaredValueType = "string";
                fullValueType = "String";
                break;
            default:
                if (typeArgument is not { Name: "Guid", ContainingNamespace: { Name: "System", ContainingNamespace.IsGlobalNamespace: true } })
                    return null;
                declaredValueType = "Guid";
                fullValueType = "Guid";
                break;
        }

        var symbol = new Identifier(containingDeclarations, symbolName, isStruct, isPublic, declaredValueType, fullValueType);

        return symbol;
    }

    private static void GenerateIdentifier(SourceProductionContext context, ImmutableArray<Identifier> generatedIdentifiers)
    {
        foreach (var symbol in generatedIdentifiers)
        {
            var symbolNamespace = symbol.ContainingDeclarations.ToNamespace();
            var symbolName = symbol.Name;
            var isStruct = symbol.IsStruct;
            var isPublic = symbol.IsPublic;
            var declaredValueType = symbol.DeclaredValueType;
            var fullValueType = symbol.FullValueType;

            var source = new StringBuilder();

            source.AppendLine($"""
                               //-----------------------------------------------------------------------------
                               // <auto-generated>
                               // This code was generated by {nameof(GeneratedIdentifierSourceGenerator)} which
                               // can be found in the {typeof(GeneratedIdentifierSourceGenerator).Namespace} namespace.
                               //
                               // Changes to this file may cause incorrect behavior
                               // and will be lost if the code is regenerated.
                               // </auto-generated>
                               //-----------------------------------------------------------------------------

                               #nullable enable

                               using System.ComponentModel;
                               using System.Globalization;
                               using System.Text.Json;
                               using System.Text.Json.Serialization;
                               using LightResults;
                               using LightResults.Extensions.ValueObjects;

                               """
            );

            if (symbolNamespace.Length > 0)
                source.AppendLine($"""
                                   namespace {symbolNamespace};

                                   """
                );

            source.AppendLine($$"""
                                [TypeConverter(typeof({{symbolName}}TypeConverter))]
                                [JsonConverter(typeof({{symbolName}}JsonConverter))]
                                {{(isPublic ? "public" : "internal")}} {{(isStruct ? "readonly" : "sealed")}} partial {{(isStruct ? "struct" : "class")}} {{symbolName}} :
                                    ICreatableValueObject<{{declaredValueType}}, {{symbolName}}>,
                                """
            );

            if (declaredValueType != "string")
                source.AppendLine($$"""
                                        IParsableValueObject<{{symbolName}}>,
                                    """
                );

            source.AppendLine($$"""
                                    IValueObject<{{declaredValueType}}, {{symbolName}}>,
                                    IComparable<{{symbolName}}>,
                                    IComparable
                                {
                                """
            );

            if (isStruct)
                source.AppendLine("""
                                      /// <summary>Gets whether this identifier is the default value.</summary>
                                      public bool IsDefault => _value == default;

                                  """
                );

            source.AppendLine($"""
                                   {declaredValueType} IValueObject<{declaredValueType}, {symbolName}>.Value => _value;
                               
                                   private readonly {declaredValueType} _value;

                               """
            );

            source.AppendLine($$"""
                                    private {{symbolName}}({{declaredValueType}} value, bool skipValidation = false)
                                    {
                                        if (!skipValidation)
                                            ValueObjectException.ThrowIfFailed(Validate(value));
                                
                                        _value = value;
                                    }

                                """
            );

            source.AppendLine($$"""
                                    /// <inheritdoc />
                                    public static {{symbolName}} Create({{declaredValueType}} value)
                                    {
                                        var result = TryCreate(value);
                                        if (result.IsSuccess(out var identifier, out var error))
                                            return identifier;
                                
                                        throw new ValueObjectException(error.Message);
                                    }

                                """
            );

            source.AppendLine($$"""
                                    /// <inheritdoc />
                                    public static Result<{{symbolName}}> TryCreate({{declaredValueType}} value)
                                    {
                                        var validation = Validate(value);
                                        if (validation.IsFailure(out var error))
                                            return Result.Failure<{{symbolName}}>(error);
                                
                                        return Result.Success<{{symbolName}}>(new {{symbolName}}(value, true));
                                    }

                                """
            );

            if (declaredValueType != "string")
            {
                source.AppendLine($$"""
                                        /// <inheritdoc />
                                        public static {{symbolName}} Parse(string s)
                                        {
                                            var result = TryParse(s);
                                            if (result.IsSuccess(out var identifier, out var error))
                                                return identifier;
                                    
                                            throw new ValueObjectException(error.Message);
                                        }

                                    """
                );

                source.AppendLine($$"""
                                        /// <inheritdoc />
                                        public static Result<{{symbolName}}> TryParse(string s)
                                        {
                                            if ({{declaredValueType}}.TryParse(s, out var value))
                                                return TryCreate(value);
                                    
                                            return Result.Failure<{{symbolName}}>("The string is not a valid identifier.");
                                        }

                                    """
                );

                source.AppendLine($$"""
                                        /// <inheritdoc />
                                        public static bool TryParse(string s, out {{symbolName}} identifier)
                                        {
                                            return TryParse(s).IsSuccess(out identifier);
                                        }

                                    """
                );

                source.AppendLine($$"""
                                        /// <inheritdoc />
                                        public static bool TryParse(string s, IFormatProvider provider, out {{symbolName}} identifier)
                                        {
                                            return TryParse(s).IsSuccess(out identifier);
                                        }

                                    """
                );
            }

            if (isStruct)
                source.AppendLine($$"""
                                        /// <inheritdoc />
                                        public bool Equals({{symbolName}} other)
                                        {
                                            return {{(declaredValueType is "string" ?
                                                "string.Equals(_value, other._value, StringComparison.Ordinal)" :
                                                "_value.Equals(other._value)")}};
                                        }

                                    """
                );
            else
                source.AppendLine($$"""
                                      /// <inheritdoc />
                                      public bool Equals({{symbolName}}? other)
                                      {
                                          if (other is null)
                                              return false;
                                          if (ReferenceEquals(this, other))
                                              return true;
                                          return {{(declaredValueType is "string" ?
                                              "string.Equals(_value, other._value, StringComparison.Ordinal)" :
                                              "_value.Equals(other._value)")}};
                                      }

                                    """
                );

            if (isStruct)
                source.AppendLine($$"""
                                        /// <inheritdoc />
                                        public override bool Equals(object? obj)
                                        {
                                            return obj is {{symbolName}} other && Equals(other);
                                        }

                                    """
                );
            else
                source.AppendLine($$"""
                                        /// <inheritdoc />
                                        public override bool Equals(object? obj)
                                        {
                                            if (obj is null)
                                                return false;
                                            if (ReferenceEquals(this, obj))
                                                return true;
                                            return obj is {{symbolName}} other && Equals(other);
                                        }

                                    """
                );

            if (declaredValueType is "long" or "Guid" or "string")
                source.AppendLine($$"""
                                      /// <inheritdoc />
                                      public override int GetHashCode()
                                      {
                                          return {{(declaredValueType is "string" ?
                                                  "StringComparer.Ordinal.GetHashCode(_value)" :
                                                  "_value.GetHashCode()")}};
                                      }

                                  """
                );
            else
                source.AppendLine("""
                                      /// <inheritdoc />
                                      public override int GetHashCode()
                                      {
                                          return _value;
                                      }

                                  """
                );

            if (isStruct)
                source.AppendLine($$"""
                                        /// <summary>Determines whether two instances of <see cref="{{symbolName}}" /> are equal.</summary>
                                        /// <param name="left">The first instance to compare.</param>
                                        /// <param name="right">The second instance to compare.</param>
                                        /// <returns><c>true</c> if the instances are equal; otherwise, <c>false</c>.</returns>
                                        public static bool operator ==({{symbolName}} left, {{symbolName}} right)
                                        {
                                            return left.Equals(right);
                                        }

                                    """
                );
            else
                source.AppendLine($$"""
                                        /// <summary>Determines whether two instances of <see cref="{{symbolName}}" /> are equal.</summary>
                                        /// <param name="left">The first instance to compare.</param>
                                        /// <param name="right">The second instance to compare.</param>
                                        /// <returns><c>true</c> if the instances are equal; otherwise, <c>false</c>.</returns>
                                        public static bool operator ==({{symbolName}}? left, {{symbolName}}? right)
                                        {
                                            if (left is null && right is null)
                                                return true;
                                            if (left is null || right is null)
                                                return false;
                                            if (ReferenceEquals(left, right))
                                                return true;
                                            return left.Equals(right);
                                        }

                                    """
                );

            if (isStruct)
                source.AppendLine($$"""
                                        /// <summary>Determines whether two instances of <see cref="{{symbolName}}" /> are not equal.</summary>
                                        /// <param name="left">The first instance to compare.</param>
                                        /// <param name="right">The second instance to compare.</param>
                                        /// <returns><c>true</c> if the instances are not equal; otherwise, <c>false</c>.</returns>
                                        public static bool operator !=({{symbolName}} left, {{symbolName}} right)
                                        {
                                            return !left.Equals(right);
                                        }

                                    """
                );
            else
                source.AppendLine($$"""
                                        /// <summary>Determines whether two instances of <see cref="{{symbolName}}" /> are not equal.</summary>
                                        /// <param name="left">The first instance to compare.</param>
                                        /// <param name="right">The second instance to compare.</param>
                                        /// <returns><c>true</c> if the instances are not equal; otherwise, <c>false</c>.</returns>
                                        public static bool operator !=({{symbolName}}? left, {{symbolName}}? right)
                                        {
                                            if (left is null && right is null)
                                                return false;
                                            if (left is null || right is null)
                                                return true;
                                            if (ReferenceEquals(left, right))
                                                return false;
                                            return !left.Equals(right);
                                        }

                                    """
                );

            if (isStruct)
                source.AppendLine($$"""
                                        /// <inheritdoc />
                                        public int CompareTo({{symbolName}} other)
                                        {
                                            return _value.CompareTo(other._value);
                                        }

                                    """
                );
            else
                source.AppendLine($$"""
                                        /// <inheritdoc />
                                        public int CompareTo({{symbolName}}? other)
                                        {
                                            if (other is null)
                                                return 1;
                                            if (ReferenceEquals(this, other))
                                                return 0;
                                            return {{(declaredValueType is "string" ?
                                                "string.Compare(_value, other._value, StringComparison.Ordinal)" :
                                                "_value.CompareTo(other._value)")}};
                                        }

                                    """
                );

            if (isStruct)
                source.AppendLine($$"""
                                        /// <inheritdoc />
                                        public int CompareTo(object? obj)
                                        {
                                            if (ReferenceEquals(null, obj))
                                                return 1;
                                            return obj is {{symbolName}} other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof({{symbolName}})}.");
                                        }

                                    """
                );
            else
                source.AppendLine($$"""
                                        /// <inheritdoc />
                                        public int CompareTo(object? obj)
                                        {
                                            if (obj is null)
                                                return 1;
                                            if (ReferenceEquals(this, obj))
                                                return 0;
                                            return obj is {{symbolName}} other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof({{symbolName}})}.");
                                        }

                                    """
                );

            if (isStruct)
                source.AppendLine($$"""
                                        /// <summary>Determines whether the first instance of <see cref="{{symbolName}}" /> is less than the second instance.</summary>
                                        /// <param name="left">The first instance to compare.</param>
                                        /// <param name="right">The second instance to compare.</param>
                                        /// <returns><c>true</c> if the first instance is less than the second instance; otherwise, <c>false</c>.</returns>
                                        public static bool operator <({{symbolName}} left, {{symbolName}} right)
                                        {
                                            return left.CompareTo(right) < 0;
                                        }

                                    """
                );
            else
                source.AppendLine($$"""
                                        /// <summary>Determines whether the first instance of <see cref="{{symbolName}}" /> is less than the second instance.</summary>
                                        /// <param name="left">The first instance to compare.</param>
                                        /// <param name="right">The second instance to compare.</param>
                                        /// <returns><c>true</c> if the first instance is less than the second instance; otherwise, <c>false</c>.</returns>
                                        public static bool operator <({{symbolName}}? left, {{symbolName}}? right)
                                        {
                                            if (left is null)
                                                return (right is null ? 0 : -1) < 0;
                                            return left.CompareTo(right) < 0;
                                        }

                                    """
                );

            if (isStruct)
                source.AppendLine($$"""
                                        /// <summary>Determines whether the first instance of <see cref="{{symbolName}}" /> is greater than the second instance.</summary>
                                        /// <param name="left">The first instance to compare.</param>
                                        /// <param name="right">The second instance to compare.</param>
                                        /// <returns><c>true</c> if the first instance is greater than the second instance; otherwise, <c>false</c>.</returns>
                                        public static bool operator >({{symbolName}} left, {{symbolName}} right)
                                        {
                                            return left.CompareTo(right) > 0;
                                        }

                                    """
                );
            else
                source.AppendLine($$"""
                                        /// <summary>Determines whether the first instance of <see cref="{{symbolName}}" /> is greater than the second instance.</summary>
                                        /// <param name="left">The first instance to compare.</param>
                                        /// <param name="right">The second instance to compare.</param>
                                        /// <returns><c>true</c> if the first instance is greater than the second instance; otherwise, <c>false</c>.</returns>
                                        public static bool operator >({{symbolName}}? left, {{symbolName}}? right)
                                        {
                                            if (left is null)
                                                return false;
                                            return left.CompareTo(right) > 0;
                                        }

                                    """
                );

            if (isStruct)
                source.AppendLine($$"""
                                        /// <summary>Determines whether the first instance of <see cref="{{symbolName}}" /> is less than or equal to the second instance.</summary>
                                        /// <param name="left">The first instance to compare.</param>
                                        /// <param name="right">The second instance to compare.</param>
                                        /// <returns><c>true</c> if the first instance is less than or equal to the second instance; otherwise, <c>false</c>.</returns>
                                        public static bool operator <=({{symbolName}} left, {{symbolName}} right)
                                        {
                                            return left.CompareTo(right) <= 0;
                                        }

                                    """
                );
            else
                source.AppendLine($$"""
                                        /// <summary>Determines whether the first instance of <see cref="{{symbolName}}" /> is less than or equal to the second instance.</summary>
                                        /// <param name="left">The first instance to compare.</param>
                                        /// <param name="right">The second instance to compare.</param>
                                        /// <returns><c>true</c> if the first instance is less than or equal to the second instance; otherwise, <c>false</c>.</returns>
                                        public static bool operator <=({{symbolName}}? left, {{symbolName}}? right)
                                        {
                                            if (left is null)
                                                return true;
                                            return left.CompareTo(right) <= 0;
                                        }

                                    """
                );

            if (isStruct)
                source.AppendLine($$"""
                                        /// <summary>Determines whether the first instance of <see cref="{{symbolName}}" /> is greater than or equal to the second instance.</summary>
                                        /// <param name="left">The first instance to compare.</param>
                                        /// <param name="right">The second instance to compare.</param>
                                        /// <returns><c>true</c> if the first instance is greater than or equal to the second instance; otherwise, <c>false</c>.</returns>
                                        public static bool operator >=({{symbolName}} left, {{symbolName}} right)
                                        {
                                            return left.CompareTo(right) >= 0;
                                        }

                                    """
                );
            else
                source.AppendLine($$"""
                                        /// <summary>Determines whether the first instance of <see cref="{{symbolName}}" /> is greater than or equal to the second instance.</summary>
                                        /// <param name="left">The first instance to compare.</param>
                                        /// <param name="right">The second instance to compare.</param>
                                        /// <returns><c>true</c> if the first instance is greater than or equal to the second instance; otherwise, <c>false</c>.</returns>
                                        public static bool operator >=({{symbolName}}? left, {{symbolName}}? right)
                                        {
                                            if (left is null)
                                                return (right is null ? 0 : -1) >= 0;
                                            return left.CompareTo(right) >= 0;
                                        }

                                    """
                );

            if (declaredValueType != "string")
                source.AppendLine($$"""
                                        /// <summary>Gets the underlying value of the <see cref="{{symbolName}}" />.</summary>
                                        /// <returns>The underlying value of the <see cref="{{symbolName}}" />.</returns>
                                        public {{declaredValueType}} To{{fullValueType}}()
                                        {
                                            return _value;
                                        }

                                    """
                );

            if (declaredValueType == "Guid")
                source.AppendLine("""
                                      /// <inheritdoc />
                                      public override string ToString()
                                      {
                                          return _value.ToString();
                                      }

                                  """
                );
            else if (declaredValueType == "string")
                source.AppendLine("""
                                      /// <inheritdoc />
                                      public override string ToString()
                                      {
                                          return _value;
                                      }

                                  """
                );
            else
                source.AppendLine("""
                                      /// <inheritdoc />
                                      public override string ToString()
                                      {
                                          return _value.ToString(CultureInfo.InvariantCulture);
                                      }

                                  """
                );

            if (declaredValueType == "Guid")
                source.AppendLine($$"""
                                        private static Result Validate({{declaredValueType}} value)
                                        {
                                            return Result.Success();
                                        }
                                    """
                );
            else if (declaredValueType == "string")
                source.AppendLine($$"""
                                        private static Result Validate({{declaredValueType}} value)
                                        {
                                            if (string.IsNullOrWhiteSpace(value))
                                                return Result.Failure("The value must not be empty.");
                                    
                                            return Result.Success();
                                        }
                                    """
                );
            else
                source.AppendLine($$"""
                                        private static Result Validate({{declaredValueType}} value)
                                        {
                                            if (value < 0)
                                                return Result.Failure("The value must be equal to or greater than zero.");
                                    
                                            return Result.Success();
                                        }
                                    """
                );

            source.AppendLine("""
                              }

                              """
            );

            source.AppendLine($$"""
                                {{(isPublic ? "public" : "internal")}} sealed class {{symbolName}}TypeConverter : TypeConverter
                                {
                                    public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType)
                                    {
                                        return sourceType == typeof({{declaredValueType}}) || base.CanConvertFrom(context, sourceType);
                                    }
                                
                                    public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value)
                                    {
                                        if (value is {{declaredValueType}} identifierValue)
                                            return {{symbolName}}.Create(identifierValue);
                                
                                        return base.ConvertFrom(context, culture, value);
                                    }
                                }

                                """
            );
            source.AppendLine($$"""
                                {{(isPublic ? "public" : "internal")}} sealed class {{symbolName}}JsonConverter : JsonConverter<{{symbolName}}>
                                {
                                    public override void Write(Utf8JsonWriter writer, {{symbolName}} identifier, JsonSerializerOptions options)
                                    {
                                        var value = ((IValueObject<{{declaredValueType}}, {{symbolName}}>)identifier).Value;
                                """
            );

            if (declaredValueType == "Guid")
                source.AppendLine("""        writer.WriteStringValue(value.ToString());""");
            else if (declaredValueType == "string")
                source.AppendLine("""        writer.WriteStringValue(value);""");
            else
                source.AppendLine("""        writer.WriteNumberValue(value);""");

            source.AppendLine($$"""
                                    }
                                
                                    public override {{symbolName}} Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                                    {
                                        var value = reader.Get{{fullValueType}}();
                                """
            );
            if (declaredValueType == "string")
                source.AppendLine("""
                                          if (string.IsNullOrWhiteSpace(value))
                                              throw new InvalidOperationException("The value must not be empty.");

                                  """
                );
            source.Append($$"""
                                    return {{symbolName}}.Create(value);
                                }
                            }

                            """
            );

            var hint = $"{symbol.ContainingDeclarations.ToFullyQualifiedName()}.{symbol.Name}.g.cs";
            context.AddSource(hint, source.ToString());
        }
    }

    private readonly record struct Identifier(
        EquatableImmutableArray<Declaration> ContainingDeclarations,
        string Name,
        bool IsStruct,
        bool IsPublic,
        string DeclaredValueType,
        string FullValueType
    )
    {
        public EquatableImmutableArray<Declaration> ContainingDeclarations { get; } = ContainingDeclarations;
        public string Name { get; } = Name;
        public bool IsStruct { get; } = IsStruct;
        public bool IsPublic { get; } = IsPublic;
        public string DeclaredValueType { get; } = DeclaredValueType;
        public string FullValueType { get; } = FullValueType;
    }
}
